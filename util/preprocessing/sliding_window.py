from torchvision.datasets.video_utils import VideoClips
import torchvision, cv2, torch
import numpy as np

from os import listdir, mkdir, makedirs
from os.path import isfile, join, splitext, exists
from shutil import rmtree

"""
The script applies the sliding window method for a given video. However, each sample 
that is generated by the sliding window is divided into subclips due to memory constraints.
All subclips for a sample are located in a single directory

Usage:
python util/preprocessing/sliding_window.py
"""


def rotate(image, **kwargs):
    image_center = tuple(np.array(image.shape[1::-1]) / 2)
    rot_mat = cv2.getRotationMatrix2D(image_center, kwargs["rotation"], 1.0)
    result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)
    return result


def sliding_window(video_path, save_path, epoch_id, preprocess=[]):
    T = 300
    no_subsets = 2

    videoclips = VideoClips([video_path], clip_length_in_frames=int(T/no_subsets), frames_between_clips=1)

    filenames = []
    rotation = 0
    sample_count = -1
    sample_dir = ""
    sample_id = ""
    for i in range(len(videoclips)):

        if i % no_subsets == 0:
            sample_count += 1
            # New sample, create new preprocess values
            rnd = np.random.uniform(-1,1)
            rotation = 45 * rnd

            # Create save directory
            sample_id = str(epoch_id) + str(sample_count)
            sample_dir = join(save_path, sample_id)
            mkdir(sample_dir)

        # Preprocess
        clip,_,_, _ = videoclips.get_clip(i)
        clip = clip.numpy()

        for f in range(len(clip)):
            for p in preprocess:
                clip[f] = p(clip[f], rotation=rotation)
        
        clip = torch.tensor(clip)

        # Save
        filename = "{}/{}{}.mp4".format(sample_id, str(sample_count), str(i%no_subsets))
        filepath = join(save_path, filename)
        torchvision.io.write_video(filepath, clip, 30)
        filenames.append(filename)
        print(filepath)

        # debug
        if i > 4:
            break

    return filenames


def main(input_dir, output_dir, dataset_name, epochs=1):
    videos = [f for f in listdir(input_dir) if isfile(join(input_dir, f))]
    labels = [splitext(f)[0] for f in videos ]

    working_dir = join(output_dir, dataset_name)

    # Because I will probably need to run the script on multiple occasion per class, we remove this for now...
    # if exists(working_dir):
        # rmtree(working_dir)

    samples_dir = join(working_dir, "samples")
    makedirs(samples_dir)

    annotations_file = join(working_dir, "annotations.csv")
    # setup csv
    with open(annotations_file, "a") as f:
        f.write("# filename,label\n")

    preprocess = [rotate] # list of functions
    for e in range(epochs):
        for v, l in zip(videos, labels):
            class_dir = join(samples_dir, l)
            mkdir(class_dir)

            filenames = sliding_window(join(input_dir,v), class_dir, e, preprocess=preprocess)

            # create csv from filenames
            with open(annotations_file, "a") as f:
                for name in filenames:
                    f.write("samples/{},{}\n".format(join(l,name), l))


if __name__ == "__main__":
    input_dir = "../datasets/weightlifting/sliding_window/full_videos"
    output_dir = "../datasets/weightlifting"
    main(input_dir, output_dir, "videos2")
